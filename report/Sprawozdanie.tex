\documentclass{mwrep}

% Polskie znaki
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{indentfirst}

% Strona tytułowa
\usepackage{pgfplots}
\usepackage{siunitx}
\usepackage{paracol}

% Pływające obrazki
\usepackage{float}
\usepackage{svg}
\usepackage{graphicx}

% table of contents refs
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{booktabs}
\usepackage{listings}


\SendSettingsToPgf
\title{\bf Sprawozdanie z bloku drugiego \vskip 0.1cm}
\author{Konrad Winnicki \\ Jakub Sikora}
\date{\today}
\pgfplotsset{compat=1.15}	
\begin{document}

\makeatletter
\renewcommand{\maketitle}{\begin{titlepage}
		\begin{center}{
				\LARGE {\bf Politechnika Warszawska}}\\
            \vspace{0.4cm}
            \leftskip-0.9cm
            {\LARGE {\bf \mbox{Wydział Elektroniki i Technik Informacyjnych}}}\\
            \vspace{0.2cm}
            {\LARGE {\bf \mbox{Instytut Automatyki i Informatyki Stosowanej}}}\\
            
            \vspace{5cm}
            \leftskip-0.5cm
			{\bf \Huge \mbox{Sterowanie i symulacja robotów} \vskip 0.1cm}
		\end{center}
		\vspace{0.1cm}

		\begin{center}
			{\bf \LARGE \@title}
		\end{center}

		\vspace{10cm}
		\begin{paracol}{2}
			\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
			\subsection*{Zespół:}
			\bf{ \Large{ \noindent\@author \par}}
			\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

			\switchcolumn \addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
			\subsection*{Prowadzący:}
			\bf{\Large{\noindent mgr. inż. Wojciech \\ Dudek}}
			\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

		\end{paracol}
		\vspace*{\stretch{6}}
		\begin{center}
			\bf{\large{Warszawa, \@date\vskip 0.1cm}}
		\end{center}
	\end{titlepage}
}
\makeatother
\maketitle

\tableofcontents

\chapter{Laboratorium 1}

\section{Znalezione błędy w funkcjonowaniu systemu robota}
W trakcie zajęć po wprowadzeniu przez prowadzącego kilku modyfikacji,
system robota przestał działać poprawnie. Po zadaniu robotowi prędkości, 
robot zatrzymywał się i ruszał w bardzo dziwny i niezrozumiały sposób.
Naszym zadaniem było zlokalizować usterki za pomocą narzędzi
systemu ROS. 

\subsection{Wykorzystane narzędzia}
Do zdiagnozowania usterki systemu wykorzystaliśmy następujące narzędzia.

\subsubsection{\texttt{rqt\_{}graph}}
Narzędzie \texttt{rqt\_{}graph} służy do wizualizacji struktury systemu. Pozwala na
śledzenie topologii komunikacji pomiędzy poszczególnymi węzłami. Za pomocą tego narzędzia
mogliśmy sprawdzić czy zaburzona została komunikacja pomiędzy węzłami oraz czy
nie dodano nowego węzła wprowadzającego zaburzenia.

\subsubsection{\texttt{rqt\_{}tf\_{}tree}}
Narzędzie \texttt{rqt\_{}tf\_{}tree} pozwala na wizualizację drzewa transformacji 
w systemie robota. Program pozwolił nam na sprawdzenie czy publikowane są wszystkie
transformację w systemie, pozwalające na poprawne wykonywanie obliczeń w systemie.

\subsubsection{\texttt{rostopic}}
Program \texttt{rostopic} jest narzędziem do sprawdzenia informacji
na temat ROS Topiców. Narzędzie to pozwala na wypisywanie wiadomości 
nadawanych na zadanym kanale, znajdywania wszystkich topiców czy publikowanie
nowych wiadomości.

\subsubsection{\texttt{rqt\_{}plot}}
Narzędzie \texttt{rqt\_{}plot} pozwala na wizualizację danych z wiadomości
na kolorowych wykresach. Zwykle używane jako pierwsze narzędzie po które sięgamy 
w trakcie pracy z systemem, to jednak w zadaniu lokalizacji usterki okazał się 
bezużyteczny. 

\subsection{Zlokalizowane usterki}
Za pomocą \texttt{rqt\_{}tf\_{}tree} udało nam się ustalić że brakuje transformacji z
układu bazy robota do układu wieży. Brak tego przekształcenia nie pozwalał chociażby
na poprawną wizualizację robota w programie \texttt{rviz}. \\
\\
Znacznie poważniejszą usterką wprowadzoną przez prowadzącego było dołączenie do systemu
nowego węzła nadającego na topic \texttt{mux\_{}vel\_{}nav/cmd\_{}vel}. Anonimowy węzeł 
udało nam się zlokalizować za pomocą narzędzia \texttt{rqt\_{}graph}. Po podsłuchaniu 
niechcianego gościa za pomocą polecenia \texttt{rostopic echo} udało nam się ustalić 
że nowy węzeł nadaje zerowe prędkości. Wyjaśnia to zrywane ruchy robota, który najpierw
otrzymywał niezerowe wartości prędkości aby następnie otrzymać polecenie zatrzymania się.

\section{Opis algorytmu interpolacji liniowej}
Głównym zadaniem do zrealizowania w trakcie laboratorium pierwszego było napisanie węzłów
implementujących względne sterowanie pozycyjne. Należało zrealizować zadanie w dwóch
wariantach. 

\subsection{Interpolacja na podstawie zadawanych prędkości}
W pierwszej wersji, interpolowaliśmy punkty wyłacznie za pomocą 
zadawanych prędkości. Węzeł był inicjalizowany w punkcie (0,0,0) a kolejne sterowania
miały być wyznaczane na podstawie domniemanej idealnie zrealizowanej poprzedniej akcji ruchu.\\
\\
\indent{} Zasada działania algorytmu wydaje się banalnie prosta. System sterowania robota cały 
czas zapamiętuje pozycję między akcjami. Po przyjściu nowego polecenia, wyznaczane są 
przemieszczenia o które należy przesunąć robota. Robot najpierw obraca się w stronę zadanego
punktu, następnie jedzie do przodu aż do wyznaczonego miejsca aby ostatecznie obrócić się do 
zadanego kąta obrotu. \\
\\
\indent{} Najciekawszym z punktu widzenia projektowania algorytmu lokomocji wydaje się sposób interpolacji położenia.
Robot poruszając się do przodu zna odległość swoją od położenia zadanego oraz prędkość jaką zadaje
na koła. Korzystając z prostego wzoru na drogę: $$ s = vt $$ możemy w prostu sposób wyznaczyć
przez ile sekund należy jechać/obracać się aby osiągnąć cel. W ten sam sposób interpolowaliśmy
pozycję kątową robota. Korzystając z zależności $$ \alpha = \omega t $$ udało nam się w prosty
sposób uzyskać zadany kąt. Z podanego sposobu korzystamy na początku ruchu aby obrócić robota w
stronę pozycji zadanej i na końcu ruchu aby obrócić robota do docelowego kąta zadanego. \\
\\
\indent{} Korzystająć z tej metody, udało nam się uzyskać wyniki
które można opisać jako wysoko niezadowalające. Nawigacja robotem w ten sposób ma wiele wad.
Jest bardzo niedokładna a błąd bardzo szybko narasta, co czyni wykonywanie złożonych zadań
przemieszczania się niemożliwymi do wykonania. Jedyną zaletą tej metody, jest jej prostota.
Można ją wykorzystać do zgrubnego przemieszczania się robota, w przypadku gdy podłoże 
nie jest śliskie oraz nie jest dostępna informacja z enkoderów.\\
\\
\subsubsection{Implementacja}
Zgodnie z przyjętą konwencją nazewniczą, węzeł wykonujący interpolację na podstawie 
zadawanych prędkości nazwaliśmy \texttt{normalmente\_{}movimiento.py}. Węzeł nasłuchuje 
nowej pozycji zadanej na topicu \texttt{new\_{}pose}, który przyjmuje wiadomości
typu \texttt{turtlesim/Pose}. Polecenie ruchu można wysłać używając przykładowego polecenia:

\begin{center}
    \texttt{rostopic pub /new\_{}pose turtlesim/Pose '{x: 2.0, y: 4.0, theta: 0}'}
\end{center}

po którym węzeł zacznie wysyłać wiadomości typu \texttt{geometry/Twist} na topic 
\texttt{mux\_{}vel\_{}nav/cmd\_{}vel}.

\newpage

\subsection{Interpolacja na podstawie danych odometrii}
W drugiej wersji węzła, implementowaliśmy interpolację liniową punktów na podstawie 
danych z odometrii. Informacja zwrotna na temat zrealizowanego położenia powinna 
pozwolić na znaczącą poprawę dokładności przemieszczania robota.\\

\indent{} Przed wyjaśnieniem zasady działania algorytmu, należy wyjaśnić czym dokładnie
jest odometria. Najogólniej rzecz biorąć, odometria to dział miernictwa, który zajmuje się 
pomiarem odległości, wykorzystującym czujniki które określają przemieszczenie względem pozycji 
początkowej. \\
\\
\indent{} W przypadku systemu robotycznego Elektron, do dyspozycji mamy dwa rodzaje czujników.
Pierwszym są enkodery umieszczone na kołach robota, które pozwalają na pomiar o ile obróciło się koło,
co przy znanym promieniu powinno z pewną precyzją zwrócić nam przemieszczenie. Drugą możliwością, jest 
zastosowanie czujnika laserowego do pomiaru przemieszczenia względem otoczenia.\\
\\
\indent{} Zasada działania algortymu nie jest specjalnie skomplikowana. Na początku obracamy robota,
aż jego orientacja wynikająca z odometrii będzie zgodna (z zadaną dokładnością) z orientacją wymaganą do jazdy
w kierunku zadanego punktu. Następnie robot jedzie prosto do momentu aż jego pozycja wynikająca
z odometrii będzie zgodna z pozycją zadaną. Ostatecznie, ponownie obracamy robota do zadanej 
orientacji w ten sam sposób w jaki to robiliśmy w pierwszej fazie ruchu.\\
\\
\indent{} Głównym czynnikiem wpływającym na jakość działania węzła jest jakość samego sygnału
z odometrii. W przypadku kierowania się sygnałem pozycji pochodzącym z enkoderów umieszczonych 
na kołach, który jest podatny na błędy z powodu poślizgów i skończonej rozdzielczości samego enkodera,
możemy nie uzyskać dokładnego odwzorowania pozycji zadanej w rzeczywistą pozycję robota. 
W celu poprawienia jakości sygnału z odometrii należy skorzystać z czujnika laserowego LIDAR, który 
zwraca położenie na podstawie przemieszczenia względem otoczenia. 
\subsubsection{Implementacja}
W celu wykonania zadania napisaliśmy skrypt \texttt{odometria\_{}movimiento.py}, który uruchamia węzeł
poruszający robotem z uwzględeniem informacji z odometrii. Podobnie jak w poprzednim zadaniu robot nasłuchuje
nowej pozycji zadanej na temacie \texttt{new\_{}pose}. Dodatkowo, umożliwiliśmy zadawanie nowej pozycji jako 
\texttt{rosservice}. Użytkownik wysyła żądanie przemieszczenia do usługi o nazwie \texttt{stero/go\_{}to\_{}stpt}.
Aby poprawnie wywołać usługę, należy wysłać wiadomość zdefiniowanego przez nas typu \texttt{stero\_{}mobile\_{}init/STPT}.
Węzeł odczytuje informacje z odometrii 
z tematu \texttt{/elektron/mobile\_{}base\_{}controller/odom}. Wiadomości nadawane na tym temacie są typu \texttt{nav/Odometry}.\\
\\
\indent{} Po poprawnym zgłoszeniu żądania przemieszczenia, robot podobnie jak w przypadku poprzedniego węzła, 
wykonuje trzystopniowe przemieszczenie się do pozycji zadanej:\\
\begin{itemize}
	\item Obrót w stronę pozycji zadanej
	\item Ruch po prostej do punktu zadanego
	\item Obrót do zadanej orientacji\\
\end{itemize}

Każda z faz jest wykonywana do momentu gdy pozycja z odometrii będzie zgodna z pozycją zadaną. Ponieważ pozycja jest 
zwracana w pewnych odstępach, przemieszczenia i obroty wykonujemy do momentu aż różnica pozycji odometrii z pozycją
zadaną będzie mniejsza od zadanego poziomu dokładności.



\chapter{Projekt 1}

\section{Struktura oprogramowania stworzonego do zbierania danych}
Diagram strukturalny (zawiera węzły/procesy składowe systemu oraz komunikację między
nimi)
\section{Opis działania węzła zbierającego dane}
Opis z diagramami
\section{Opis działania węzła sterującego robota}
Opis z diagramami
\section{Sposób analizy danych}

\section{Wykresy i wnioski}


\chapter{Laboratorium 2}

\section{Stworzone środowisko i jego mapa}

\section{Przykładowe ścieżki zaplanowane w środowiskach}

\section{Pliki uruchomieniowe symulacji}


\chapter{Projekt 2}

\section{Struktura sterownika robota}

\section{Opis działania węzła planującego}

\section{Pliki konfiguracyjne map kosztów oraz lokalnego planera}

\section{Wyjaśnienie zastosowanych parametrów}
Dlaczego taki parametr ustawiono i dlaczego taka wartość?
\section{Weryfikacja działania}
Zrzuty ekranu z zaplanowaną i wykonaną ścieżką (Typ
wizualizacji: Odometry ): http://wiki.ros.org/rviz/DisplayTypes/Odometry
\end{document}